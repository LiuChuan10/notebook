1.内存映射的原理
A：将一块内存空间映射到不同的进程空间中。内存映射是一种操作系统技术，允许程序将磁盘文件映射到进程的虚拟地址空间中，像访问内存一样访问文件。这听起来很有用，特别是在处理大文件时，因为它可以提高效率，避免传统I/O操作的开销。


2.define和const的区别
编译阶段：#define：这是一个预处理指令，它在编译前由预处理器处理。预处理器会将代码中所有出现的宏名替换为宏定义的值，因此宏定义是在文本替换阶段完成的。
          const：这是一个编译时关键字，它在编译阶段处理。const 声明的常量会被编译器识别并处理，通常会分配内存空间。
类型检查：#define：宏定义没有类型，编译器不会对宏名进行类型检查。例如，#define PI 3.14 会将 PI 替换为 3.14，但不会检查它在使用时是否被正确使用为浮点数。
          const：const 声明的常量具有类型，编译器会进行类型检查。例如，const float PI = 3.14; 声明的 PI 是一个浮点数常量，如果尝试将其赋值给一个整数变量，编译器会报错。
作用域：#define：宏定义的作用域是全局的，除非使用 #undef 取消宏定义。无论在哪个代码块中，宏名都会被替换为宏定义的值。
          const：const 声明的常量具有局部作用域，只能在声明它的代码块内使用。例如，如果在函数内部声明 const int MAX = 100;，那么这个常量只能在该函数内部使用。
内存分配：#define：由于宏定义只是文本替换，不会分配内存空间。宏名在编译时会被完全替换掉，不会在运行时占用内存。
          const：const 声明的常量会分配内存空间，通常在静态存储区或栈上分配。这使得 const 常量在运行时可以被访问和调试。
可读性与维护：#define：宏定义的代码在预处理后会被替换为原始值，这可能会降低代码的可读性，尤其是在复杂的情况下。此外，宏定义的维护可能较为困难，因为它们会影响整个代码。
          const：const 声明的常量在代码中具有明确的名称和类型，提高了代码的可读性和维护性。编译器可以提供更好的支持，例如在调试时显示常量的值。
使用方式：#define：通常用于简单的常量定义，或者需要在多个地方重复使用同一个值的场景。例如：#define MAX_SIZE 100
          const：更适合复杂的数据类型，或者需要类型安全的常量定义。例如：const float PI = 3.14f;
优缺点：#define：
        优点：简单易用，全局有效，适合需要多次重复替换的场景。
        缺点：没有类型检查，可能导致类型不匹配；无法在调试时查看宏的值。
      const：
        优点：类型安全，编译器会进行类型检查；具有明确的作用域，适合局部常量；在调试时可以查看常量的值。
        缺点：只能在声明的作用域内使用，不如宏定义全局有效；可能会占用额外的内存空间。
总结：
如果需要全局有效且简单的常量替换，可以使用 #define。
如果需要类型安全、局部作用域以及更好的调试支持，建议使用 const。

3.数组和链表的区别
4.指针和引用的区别
5.解释一下QT的信号与槽
6.IIC为什么要加上拉电阻，为什么使用开漏输出
7.MQTT的通信过程
8.在Linux中怎么实现同步
9.TCP和UDP的应用场景
10.什么是野指针，什么情况会产生野指针
11.什么是互斥锁
12.数组和指针的区别
13.如何防止重复引用头文件
14.栈和队列的区别
15.为什么中断不能传递参数
16.串口数据帧格式
17.中断的概念
18.static的作用
19.中断的执行过程
20.什么是多态
21.C语言中的内存分配方式有几种
22.struct和class的区别
23.函数和中断的区别
24.自旋锁和信号量的区别
25.怎么判断链表是否有环
26.使用多线程时需要注意什么
27.实现strcpy函数28.实现strcat函数
